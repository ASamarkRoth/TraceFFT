#include "FFT.h"

void FFT(TFile* root_results)
{

	//This tutorial illustrates the Fast Fourier Transforms interface in ROOT.
	//FFT transform types provided in ROOT:
	// - "C2CFORWARD" - a complex input/output discrete Fourier transform (DFT)
	//                  in one or more dimensions, -1 in the exponent
	// - "C2CBACKWARD"- a complex input/output discrete Fourier transform (DFT)
	//                  in one or more dimensions, +1 in the exponent
	// - "R2C"        - a real-input/complex-output discrete Fourier transform (DFT)
	//                  in one or more dimensions,
	// - "C2R"        - inverse transforms to "R2C", taking complex input
	//                  (storing the non-redundant half of a logically Hermitian array)
	//                  to real output
	// - "R2HC"       - a real-input DFT with output in Â¡ÃˆhalfcomplexÂ¡Ã‰ format,
	//                  i.e. real and imaginary parts for a transform of size n stored as
	//                  r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1
	// - "HC2R"       - computes the reverse of FFTW_R2HC, above
	// - "DHT"        - computes a discrete Hartley transform
	// Sine/cosine transforms:
	//  DCT-I  (REDFT00 in FFTW3 notation)
	//  DCT-II (REDFT10 in FFTW3 notation)
	//  DCT-III(REDFT01 in FFTW3 notation)
	//  DCT-IV (REDFT11 in FFTW3 notation)
	//  DST-I  (RODFT00 in FFTW3 notation)
	//  DST-II (RODFT10 in FFTW3 notation)
	//  DST-III(RODFT01 in FFTW3 notation)
	//  DST-IV (RODFT11 in FFTW3 notation)
	//First part of the tutorial shows how to transform the histograms
	//Second part shows how to transform the data arrays directly
	//Authors: Anna Kreshuk and Jens Hoffmann


	//********* Histograms ********//

	TraceAnalysis trace_analysis;

	//prepare the canvas for drawing
	TCanvas *myc = new TCanvas("myc", "Fast Fourier Transform", 800, 600);
	myc->SetFillColor(45);
	TPad *c1_2 = new TPad("c1_1", "c1_1",0.01,0.01,0.99,0.49);
	TPad *c1_1 = new TPad("c1_2", "c1_2",0.01,0.51,0.99,0.99);
	c1_1->Draw();
	c1_2->Draw();
	c1_1->cd();
	TH1::AddDirectory(kFALSE);

	TRandom3 rnd = TRandom3();

	Int_t T = 32;
	double w = 2*TMath::Pi() / T;
	//A function to sample
	Int_t n=600;
	Int_t step = 10;
	TF1 *fsin = new TF1("fsin", "sin([0]*x)", 0, static_cast<double>(n));
	fsin->SetParameter(0, w);
	fsin->SetNpx(100000);
	//fsin->Draw();

	TH1D *hsin = new TH1D("hsin", "hsin", n, 0, n);
	TH1D *h_lin = new TH1D("h_lin", "h_lin", step*n, 0, n);

	//Fill the histogram with function values
	for (Int_t i=0; i<=n; i++){
		//x = (Double_t(i)/n)*(n);
		hsin->SetBinContent(i, fsin->Eval(i)+rnd.Gaus(0,1));
		//hsin->SetBinContent(i, fsin->Eval(i));
	}
	hsin->Draw("same");
	fsin->GetXaxis()->SetLabelSize(0.05);
	fsin->GetYaxis()->SetLabelSize(0.05);

	trace_analysis.LinearInterpolation(hsin, h_lin, step);
	h_lin->Draw("same");

	c1_2->cd();
	//Compute the transform and look at the magnitude of the output
	TH1 *hm =0;
	TVirtualFFT::SetTransform(0);
	hm = h_lin->FFT(hm, "MAG EX");
	hm->SetTitle("Magnitude of the 1st transform");
	hm->GetXaxis()->SetLimits(0, (hm->GetXaxis()->GetXmax()/static_cast<double>(hsin->GetXaxis()->GetXmax())));
	//hm->GetXaxis()->SetLimits(0, hm->GetXaxis()->GetXmax());
	hm->Draw();
	//NOTE: for "real" frequencies you have to divide the x-axes range with the range of your function
	//(in this case 4*Pi); y-axes has to be rescaled by a factor of 1/SQRT(n) to be right: this is not done automatically!

	hm->SetStats(kFALSE);
	hm->GetXaxis()->SetLabelSize(0.05);
	hm->GetYaxis()->SetLabelSize(0.05);
	myc->Write();

	printf("\tFq=%lf\n", hm->GetBinLowEdge(hm->GetMaximumBin())+0.5*hm->GetBinWidth(hm->GetMaximumBin()));
}

void TraceFFT(std::string s_input, TFile* root_results)
{
	// example of script to loop on all the objects of a  loopdir() {    // example of s ROOT file directory
	// and print on Postscript all TH1 derived objects
	// This script uses the file generated by tutorial hsimple.C
	//Author: Rene Brun

	TFile* f1;
	TraceAnalysis trace_analysis;

	f1 = TFile::Open(s_input.c_str());

	TIter next(f1->GetListOfKeys());
	TKey *key;
	TCanvas c1;
	//c1.Print("hsimple.ps[");
	while ((key = (TKey*)next())) {
		TClass *cl = gROOT->GetClass(key->GetClassName());
		if (!cl->InheritsFrom("TH1")) continue;
		key->Print();
		TH1 *h = (TH1*)key->ReadObj();
		Int_t nbins = h->GetNbinsX();
		Int_t step = 20;
		TH1* h_mod = new TH1F("h_mod", "h_mod", nbins, 0, nbins);
		for(int j = 0; j < nbins; ++j) {
			h_mod->SetBinContent(j, h->GetBinContent(j));
		}
		TH1* h_lin = new TH1F("h_lin", "h_lin", nbins*step, 0, nbins);

		TCanvas *myc = new TCanvas("myc", "Fast Fourier Transform", 800, 600);
		TPad *c1_2 = new TPad("c1_1", "c1_1",0.01,0.01,0.99,0.49);
		TPad *c1_1 = new TPad("c1_2", "c1_2",0.01,0.51,0.99,0.99);
		c1_1->Draw();
		c1_2->Draw();
		c1_1->cd();
		TH1::AddDirectory(kFALSE);

		h_mod->Draw();
		trace_analysis.LinearInterpolation(h_mod, h_lin, step);
		h_lin->Draw("same");

		c1_2->cd();
		//Compute the transform and look at the magnitude of the output
		TH1 *hm =0;
		TVirtualFFT::SetTransform(0);
		hm = h_lin->FFT(hm, "MAG");
		hm->SetTitle("Magnitude of the 1st transform");
		hm->GetXaxis()->SetLimits(0, (hm->GetXaxis()->GetXmax()/static_cast<double>(h_mod->GetXaxis()->GetXmax())));
		hm->Draw();
		//NOTE: for "real" frequencies you have to divide the x-axes range with the range of your function
		//(in this case 4*Pi); y-axes has to be rescaled by a factor of 1/SQRT(n) to be right: this is not done automatically!

		hm->SetStats(kFALSE);
		hm->GetXaxis()->SetLabelSize(0.05);
		hm->GetYaxis()->SetLabelSize(0.05);

		myc->Write();
		root_results->Write();

		printf("\tFq=%lf\n", hm->GetBinLowEdge(hm->GetMaximumBin())+0.5*hm->GetBinWidth(hm->GetMaximumBin()));
	}
	//c1.Print("hsimple.ps]");
}





